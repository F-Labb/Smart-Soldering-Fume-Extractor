esphome:
  name: fume-extractor
  friendly_name: Дымоуловитель
  on_boot:
    priority: 600
    then:
      # Переключаем антенну
      - output.turn_off: ant_gpio3
      - output.turn_on:  ant_gpio14

      # Переводим в сон
      - fan.turn_off: absorber_fan
      - script.execute: delayed_stop

esp32:
  board: esp32-c6-devkitc-1
  framework:
    type: esp-idf

api:
  encryption:
    key: "xxx"

ota:
  - platform: esphome
    password: "xxx"

network:
  enable_ipv6: true

openthread:
  device_type: FTD
  tlv: !secret thread_tlv

substitutions:
  rotary_btn_pin: GPIO19 # Кнопка энкодера
  rotary_pina: GPIO20    # Энкодер А
  rotary_pinb: GPIO18    # Энкодер Б
  fan_out: GPIO17        # Выход вентелятолра
  i2c_sda: GPIO22        # SDA
  i2c_scl: GPIO23        # SCL

i2c:
  sda: ${i2c_sda}
  scl: ${i2c_scl}
  frequency: 800kHz # Увеличиваем частоту для повышения скорости отклика экрана

globals:
  - id: menu_level  # Уровень меню
    type: int
    initial_value: '0'
  - id: menu_index  # Выбранный пункт
    type: int
    initial_value: '0'
  - id: system_active # Активность системы
    type: bool
    initial_value: 'true'
  - id: is_splash
    type: bool
    initial_value: 'false'
  - id: fan_speed_mem
    type: int
    restore_value: yes
    initial_value: '100'

number:
  - platform: template
    name: "Яркость"
    id: disp_br_setting
    optimistic: True
    restore_value: True
    min_value: 1
    max_value: 100
    step: 10
    initial_value: 100
    on_value:
      then:
        - lambda: 'id(oled_display).set_contrast(x / 100.0f);'

  - platform: template
    name: "Сон"
    id: sleep_delay_setting
    optimistic: True
    restore_value: True
    min_value: 0
    max_value: 60
    step: 10
    initial_value: 10
    unit_of_measurement: "s"

output:
  - platform: ledc
    pin: ${fan_out}
    id: fan_pwm
    frequency: 25kHz # Стандартно для компьютерного вентелятора

# Выходы антенн. Только для C6 SuperMini от SeedStudio. Нужна внешняя антенна.
  - platform: gpio
    id: ant_gpio3
    pin: GPIO3
  - platform: gpio
    id: ant_gpio14
    pin: GPIO14

fan:
  - platform: speed
    output: fan_pwm
    id: absorber_fan
    name: "Вытяжка"
    restore_mode: RESTORE_DEFAULT_OFF
    on_speed_set:
      - lambda: |-
          // Сохраняем только если скорость больше нуля
          if (x > 0) {
            id(fan_speed_mem) = x;
          }
    on_turn_on:
      - script.execute: activity_detected
    on_turn_off:
      - script.execute: activity_detected

script:
  - id: activity_detected
    then:
      - lambda: |-
          if (!id(system_active)) {
            id(system_active) = true;
            id(oled_display).turn_on();
            // Восстанавливаем скорость из памяти при включении
            auto call = id(absorber_fan).make_call();
            call.set_state(true);
            call.set_speed(id(fan_speed_mem)); // Используем нашу глобальную переменную
            call.perform();
          }
      - script.execute: delayed_stop

  - id: delayed_stop
    mode: restart
    then:
      - delay: !lambda "return (int)id(sleep_delay_setting).state * 1000;"
      - lambda: |-
          // Если вентилятор работает перезапускаем ожидание
          if (id(absorber_fan).state) {
            id(delayed_stop).execute();
            return;
          }
          // Если вентилятор выключен и нет активности — гасим экран
          id(system_active) = false;
          id(menu_level) = 0;
          id(oled_display).turn_off();

binary_sensor:
  - platform: gpio
    id: encoder_button
    pin:
      number: ${rotary_btn_pin}
      mode: INPUT_PULLUP
      inverted: true
    on_click:
      - min_length: 50ms
        max_length: 200ms
        then:
          - if:
              condition:
                lambda: 'return id(system_active);'
              then:
                - script.execute: activity_detected
                - lambda: |-
                    if (id(menu_level) == 0) id(menu_level) = 1;
                    else if (id(menu_level) == 1) id(menu_level) = 2;
                    else id(menu_level) = 1;
      - min_length: 500ms
        max_length: 800ms
        then:
          - lambda: |-
              if (id(system_active)) {
                if (id(menu_level) > 0) {
                  id(menu_level) = 0;
                } else {
                  // ВЫКЛЮЧЕНИЕ
                  auto call = id(absorber_fan).make_call();
                  call.set_state(false);
                  call.perform();
                  id(system_active) = false;
                  id(oled_display).turn_off();
                }
              } else {
                // ВКЛЮЧЕНИЕ
                id(is_splash) = true;
                id(system_active) = true;
                id(oled_display).turn_on();
                // Запуск вентилятора с сохраненой скоростью
                auto call = id(absorber_fan).make_call();
                call.set_state(true);
                call.set_speed(id(fan_speed_mem));
                call.perform();
              }
          - if:
              condition:
                lambda: 'return id(is_splash);'
              then:
                - delay: 3s
                - lambda: 'id(is_splash) = false;'
                - script.execute: delayed_stop

sensor:
  - platform: rotary_encoder
    id: encoder
    pin_a: ${rotary_pina}
    pin_b: ${rotary_pinb}
    on_clockwise:
      then:
        - if:
            condition:
              lambda: 'return id(system_active);'
            then:
        - lambda: |-
            if (!id(system_active)) return;
            // Крутим скорость +
            if (id(menu_level) == 0) {
                auto call = id(absorber_fan).make_call();
                int cur_speed = id(absorber_fan).speed;
                int new_speed = (cur_speed < 10) ? 10 : clamp(cur_speed + 10, 0, 100);
                call.set_speed(new_speed);
                call.set_state(true);
                call.perform();
            }
            // Листаем меню вниз
            else if (id(menu_level) == 1) {
                id(menu_index) = clamp(id(menu_index) + 1, 0, 1);
            }
            // Крутим яркость и задержку сна +
            else if (id(menu_level) == 2) {
                if (id(menu_index) == 0) {
                    auto br = id(disp_br_setting).make_call();
                    br.set_value(clamp(id(disp_br_setting).state + 10.0f, 1.0f, 100.0f));
                    br.perform();
                } else if (id(menu_index) == 1) {
                    auto sd = id(sleep_delay_setting).make_call();
                    sd.set_value(clamp(id(sleep_delay_setting).state + 10.0f, 1.0f, 60.0f));
                    sd.perform();
                }
            }

    on_anticlockwise:
      then:
        - lambda: |-
            if (!id(system_active)) return;
            id(activity_detected).execute();
            if (!id(system_active)) return;
            // Крутим скорость -
            if (id(menu_level) == 0) {
                auto call = id(absorber_fan).make_call();
                int cur_speed = id(absorber_fan).speed;
                int new_speed = cur_speed - 10;
                if (new_speed < 10) {
                    call.set_speed(0);
                    call.set_state(false);
                } else {
                    call.set_speed(new_speed);
                    call.set_state(true);
                }
                call.perform();
            }
            // Листаем меню вверх
            else if (id(menu_level) == 1) {
                id(menu_index) = clamp(id(menu_index) - 1, 0, 1);
            }
            // Крутим яркость и задержку сна -
            else if (id(menu_level) == 2) {
                if (id(menu_index) == 0) {
                    auto br = id(disp_br_setting).make_call();
                    br.set_value(clamp(id(disp_br_setting).state - 10.0f, 1.0f, 100.0f));
                    br.perform();
                } else if (id(menu_index) == 1) {
                    auto sd = id(sleep_delay_setting).make_call();
                    sd.set_value(clamp(id(sleep_delay_setting).state - 10.0f, 1.0f, 60.0f));
                    sd.perform();
                }
            }

font:
  # Шрифт для иконок
  - file:
      type: gfonts
      family: "Material Icons"
    id: font_icon
    size: 24
    glyphs:
      - "\ue425" # Таймер
      - "\ue1ad" # Низкая яркость
      - "\ue1ae" # Средняя яркость
      - "\ue1ac" # Высокая яркость
      - "\ue837" # Включен
      - "\ue836" # Выключен
      - "\ue87d" # Стартовый экран

  - file:
      type: gfonts
      family: "Roboto Mono"
      weight: 700
    id: font_lg
    size: 13
    glyphs: '!"%()*-+,./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz '

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x32"
    id: oled_display
    lambda: |-
      // Функция для отрисовки капсульной рамки
      auto draw_capsule = [&](int x, int y, int w, int h, Color color) {
        it.line(x + 3, y, x + w - 4, y, color);
        it.line(x + 3, y + h - 1, x + w - 4, y + h - 1, color);
        it.line(x, y + 3, x, y + h - 4, color);
        it.line(x + w - 1, y + 3, x + w - 1, y + h - 4, color);
        it.draw_pixel_at(x + 1, y + 1, color);
        it.draw_pixel_at(x + 2, y, color);
        it.draw_pixel_at(x, y + 2, color);
        it.draw_pixel_at(x + w - 2, y + 1, color);
        it.draw_pixel_at(x + w - 3, y, color);
        it.draw_pixel_at(x + w - 1, y + 2, color);
        it.draw_pixel_at(x + 1, y + h - 2, color);
        it.draw_pixel_at(x + 2, y + h - 1, color);
        it.draw_pixel_at(x, y + h - 3, color);
        it.draw_pixel_at(x + w - 2, y + h - 2, color);
        it.draw_pixel_at(x + w - 3, y + h - 1, color);
        it.draw_pixel_at(x + w - 1, y + h - 3, color);
      };
      // 1. ЗАСТАВКА
      if (id(is_splash)) {
        it.printf(62, 8, id(font_lg), "F-LAB");
        it.printf(45, 18, id(font_icon), TextAlign::CENTER, "\ue87d");
        return;
        }

      // Если устройство выключено — черный экран
      if (!id(system_active)) return;

      // 2. ГЛАВНЫЙ ЭКРАН
      if (id(menu_level) == 0) {
        bool fan_on = id(absorber_fan).state;
        float speed_pct = fan_on ? (float)id(absorber_fan).speed : 0.0f;
        const char* fan_icon = fan_on ? "\ue837" : "\ue836";
        it.printf(15, 18, id(font_icon), TextAlign::CENTER, fan_icon);
        it.printf(35, 2, id(font_lg), "Power");
        it.printf(123, 2, id(font_lg), TextAlign::TOP_RIGHT, "%.0f%%", speed_pct);
        draw_capsule(35, 22, 88, 8, Color::WHITE);
        int bar_w = (int)((speed_pct / 100.0f) * 84);
        if (bar_w > 0) {
          it.filled_rectangle(37, 24, bar_w, 4, Color::WHITE);
        }
      }

      // 3. МЕНЮ (Level 1 - Список)
      else if (id(menu_level) == 1) {
        if (id(menu_index) == 0) {
          // Динамическая иконка яркости в меню
          float br = id(disp_br_setting).state;
          const char* br_icon = (br < 33.0f) ? "\ue1ad" : (br > 70.0f ? "\ue1ac" : "\ue1ae");
          it.printf(15, 18, id(font_icon), TextAlign::CENTER, br_icon);
          it.printf(33, 8, id(font_lg), "Brightness");
        } else {
          // Иконка таймера в меню
          it.printf(15, 18, id(font_icon), TextAlign::CENTER, "\uE425");
          it.printf(33, 8, id(font_lg), "Sleep Timer");
        }
        // Полоска активного пункта справа
        it.rectangle(125, 2 + (id(menu_index) * 12), 3, 8);
      }

      // 4. СТРАНИЦЫ НАСТРОЕК (Level 2 - Регулировка)
      else if (id(menu_level) == 2) {
        if (id(menu_index) == 0) {
          float br = id(disp_br_setting).state;
          const char* br_icon = (br < 33.0f) ? "\ue1ad" : (br > 70.0f ? "\ue1ac" : "\ue1ae");
          it.printf(35, 2, id(font_lg), "Brightness");
          it.printf(15, 18, id(font_icon), TextAlign::CENTER, br_icon);
          draw_capsule(35, 22, 88, 8, Color::WHITE);
          int br_w = (int)(br * 0.84f); // 84px - рабочая область внутри капсулы
          if (br_w > 0) it.filled_rectangle(37, 24, br_w, 4);
        }
        else if (id(menu_index) == 1) {
          it.printf(35, 8, id(font_lg), "Sleep");
          it.printf(15, 18, id(font_icon), TextAlign::CENTER, "\ue425");
          it.printf(118, 8, id(font_lg), TextAlign::RIGHT, "%.0fs", id(sleep_delay_setting).state);
        }
      }
